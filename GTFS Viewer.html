<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GTFS Viewer</title>
  <style>
    :root { --bg:#0b0f14; --card:#121821; --muted:#8fa3b8; --text:#e7edf3; --border:#1f2937; }
    *{box-sizing:border-box}
    body{margin:0;font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,"Helvetica Neue",Arial;background:radial-gradient(1200px 1200px at 10% -10%,rgba(77,163,255,.08),transparent),radial-gradient(1000px 800px at 110% 10%,rgba(34,211,238,.08),transparent),var(--bg);color:var(--text);min-height:100vh}
    header{padding:20px 24px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:16px;flex-wrap:wrap}
    header h1{margin:0;font-size:18px;letter-spacing:.2px}
    .tabs{display:flex;flex-direction:column;gap:12px;align-items:flex-start;width:100%}
    .tab-header{display:flex;justify-content:space-between;align-items:center;gap:16px;width:100%;flex-wrap:wrap}
    .tab-header-left{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .tab-about{display:flex;align-items:center}
    .tab-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .tab-group{display:flex;flex-direction:column;gap:6px;align-items:flex-start}
    .tab-group-label{font-size:11px;font-weight:700;letter-spacing:.6px;text-transform:uppercase;color:var(--muted);opacity:.8}
    .tab-btn{appearance:none;background:transparent;border:1px solid var(--border);color:var(--muted);padding:8px 12px;border-radius:10px;cursor:pointer;transition:.15s ease;font-weight:600}
    .tab-btn.active{background:linear-gradient(135deg,rgba(77,163,255,.12),rgba(34,211,238,.12));color:#e7edf3;border-color:#2a3a4d}
    .container{padding:20px 24px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0));border:1px solid var(--border);border-radius:14px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.15)}
    .file-box{display:grid;gap:14px}
    label{color:var(--muted);font-weight:600}
    input[type=file]{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      border:0;
    }
    .hint{color:var(--muted);font-size:12px}
    .actions{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .btn{padding:10px 14px;border-radius:10px;border:1px solid var(--border);background:#0f1520;color:var(--text);cursor:pointer}
    .btn.primary{border-color:#2a3a4d;background:linear-gradient(135deg,rgba(77,163,255,.14),rgba(34,211,238,.14))}
    .file-trigger{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .file-trigger .btn{min-width:140px;justify-content:center;display:inline-flex;font-weight:600}
    .fail-box{margin-top:12px;padding:12px;border-radius:12px;border:1px solid rgba(229,62,62,.3);background:rgba(229,62,62,.08);}
    .fail-box h3{margin:0 0 8px;font-size:13px;color:#fca5a5;letter-spacing:.2px}
    .fail-box ul{margin:0;padding-left:18px;font-size:12px;color:#f8d7da;display:grid;gap:4px}
    .content{display:none}
    .content.active{display:block}
    table{border-collapse:collapse;width:100%;white-space:nowrap}
    thead th{position:sticky;top:0;background:#0f1520}
    th,td{border-bottom:1px solid #1c2430;padding:8px 10px;text-align:left}
    th.sortable{cursor:pointer;user-select:none}
    th.sortable .header-inner{display:inline-flex;align-items:center;gap:6px}
    th.sortable .sort-indicator{font-size:10px;opacity:.4;transition:.15s ease}
    th.sortable.sort-active .sort-indicator{opacity:1;color:#7bb8ff}
    tbody tr:hover{background:rgba(255,255,255,0.03)}
    .scroll{overflow:auto;border:1px solid var(--border);border-radius:12px;background:#0f1520}
    .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;background:#0f1520;border:1px solid var(--border);color:#8fa3b8;font-size:12px}
    .file-pill{margin-top:6px}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px;color:#c7d2fe}
    /* Filters & pagination */
    .filters th{background:#0b1420;position:sticky;top:32px;z-index:1}
    .filter-input{width:100%;padding:6px 8px;border-radius:8px;border:1px solid var(--border);background:#0f1520;color:var(--text);font-size:12px}
    .filter-input::placeholder{color:#6b7b8f}
    .toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .spacer{flex:1}
    .pagination{display:flex;align-items:center;gap:6px}
    .pagination .btn{padding:6px 10px}
    .select{padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#0f1520;color:var(--text)}
    /* Color chips */
    .chip{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--border);border-radius:999px;padding:4px 8px;background:#0f1520}
    .chip-swatch{width:14px;height:14px;border-radius:4px;border:1px solid #0003}
    .validation-card{margin-top:20px;display:inline-block;max-width:100%}
    .validation-card .scroll{display:inline-block;max-width:100%}
    .validation-card .validation-table{width:auto}
    .validation-table tbody td:nth-child(1),
    .validation-table tbody td:nth-child(2){font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:13px}
    .status-badge{display:inline-flex;align-items:center;justify-content:center;padding:4px 10px;border-radius:999px;font-weight:700;letter-spacing:.4px;color:#fff;min-width:90px;text-transform:uppercase}
    .status-pass{background:#009600}
    .status-missing-ok{background:#719600}
    .status-missing-required{background:#be0000}
    .status-forbidden{background:#be0000}
    .modal{position:fixed;inset:0;z-index:50;display:flex;align-items:center;justify-content:center;padding:24px;background:rgba(8,13,20,.65);backdrop-filter:blur(4px)}
    .modal[hidden]{display:none}
    .modal-dialog{position:relative;max-width:520px;width:100%;background:linear-gradient(180deg,rgba(17,24,39,.95),rgba(17,24,39,.9));border:1px solid var(--border);border-radius:16px;padding:24px;box-shadow:0 18px 45px rgba(0,0,0,.35);overflow:auto;max-height:90vh}
    .modal-dialog h2{margin-top:0;margin-bottom:16px;font-size:18px}
    .modal-close{position:absolute;top:14px;right:14px;background:transparent;border:1px solid transparent;color:var(--muted);width:32px;height:32px;border-radius:50%;cursor:pointer;font-size:18px;line-height:1;display:flex;align-items:center;justify-content:center}
    .modal-close:hover{background:rgba(255,255,255,.05);color:var(--text)}
    .about-body p{margin:0 0 12px;line-height:1.6;color:var(--muted)}
    .about-body p strong{color:var(--text)}
    .about-body a{color:#7bb8ff;text-decoration:none}
    .about-body a:hover{text-decoration:underline}
  </style>
</head>
<body>
  <header>
    <div class="tabs" id="tabs"></div>
  </header>

  <main class="container">
    <section id="home" class="content active">
      <div class="card">
        <p>Import <strong>GTFS files</strong> and visualize its data.<br />The <strong>OD time table</strong> appears next to Home only when <span class="kbd">trips.txt</span>, <span class="kbd">stop_times.txt</span>, and <span class="kbd">routes.txt</span> are loaded.
        <div class="file-box" ondragover="event.preventDefault()" ondrop="handleDrop(event)">
          <label for="fileInput">Select GTFS files (.txt, .csv, .zip)</label>
          <input id="fileInput" type="file" accept=".txt,.csv,.zip" multiple />
          <div class="file-trigger">
            <button class="btn primary" id="chooseBtn" type="button">Choose files</button>
            <button class="btn primary" id="importBtn">Import</button>
            <button class="btn" id="clearBtn" title="Clear tables & start over">Clear</button>
            <span class="hint">You can also drag & drop files anywhere in this panel.</span>
          </div>
          <div class="hint">GTFS ZIP bundles are supported. Tabs: Agency, Calendar, Calendar dates, Fare attributes, Fare rules, Frequencies, Routes, Shapes, Stop times, Stops, Transfers, Trips, and OD time table (derived). URLs become clickable; color fields render as swatches.</div>
          <div id="selectedFiles"></div>
          <div id="importStatus" class="pill" hidden aria-live="polite"></div>
          <div id="failedFiles" class="fail-box" hidden>
            <h3>Failed to upload</h3>
            <ul id="failedFilesList"></ul>
          </div>
        </div>
      </div>
      <div class="card validation-card" id="validationCard" hidden>
        <h2 style="margin-top:0">Missing file validation</h2>
        <p id="validationInfo" class="hint">Results are based on the current import. Requirements adjust automatically according to related files.</p>
        <div class="scroll">
          <table class="validation-table">
            <thead>
              <tr>
                <th>File</th>
                <th>Rule</th>
                <th>Result</th>
              </tr>
            </thead>
            <tbody id="validationTableBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <section id="tab-simple" class="content"></section>
    <section id="tab-agency" class="content"></section>
    <section id="tab-areas" class="content"></section>
    <section id="tab-attributions" class="content"></section>
    <section id="tab-booking_rules" class="content"></section>
    <section id="tab-calendar" class="content"></section>
    <section id="tab-calendar_dates" class="content"></section>
    <section id="tab-fare_attributes" class="content"></section>
    <section id="tab-fare_leg_join_rules" class="content"></section>
    <section id="tab-fare_leg_rules" class="content"></section>
    <section id="tab-fare_media" class="content"></section>
    <section id="tab-fare_products" class="content"></section>
    <section id="tab-fare_rules" class="content"></section>
    <section id="tab-fare_transfer_rules" class="content"></section>
    <section id="tab-feed_info" class="content"></section>
    <section id="tab-frequencies" class="content"></section>
    <section id="tab-levels" class="content"></section>
    <section id="tab-location_group_stops" class="content"></section>
    <section id="tab-location_groups" class="content"></section>
    <section id="tab-locations.geojson" class="content"></section>
    <section id="tab-networks" class="content"></section>
    <section id="tab-pathways" class="content"></section>
    <section id="tab-rider_categories" class="content"></section>
    <section id="tab-route_networks" class="content"></section>
    <section id="tab-routes" class="content"></section>
    <section id="tab-shapes" class="content"></section>
    <section id="tab-stop_areas" class="content"></section>
    <section id="tab-stop_times" class="content"></section>
    <section id="tab-stops" class="content"></section>
    <section id="tab-timeframes" class="content"></section>
    <section id="tab-transfers" class="content"></section>
    <section id="tab-translations" class="content"></section>
    <section id="tab-trips" class="content"></section>
</main>

<div id="aboutModal" class="modal" hidden role="dialog" aria-modal="true" aria-labelledby="aboutTitle" tabindex="-1">
  <div class="modal-dialog">
    <button type="button" class="modal-close" aria-label="Close About dialog">×</button>
    <div class="about-body">
      <h2 id="aboutTitle">About</h2>
      <p><strong>GTFS Viewer (Pure HTML)</strong><br />A lightweight tool to quickly inspect static GTFS feeds directly in your browser — no server or installation required.</p>
      <p><strong>About the project:</strong><br />You can fork this project on GitHub to make your own version.<br />Official repository: <a href="https://github.com/vitorstanzione/GTFS-Viewer" target="_blank" rel="noopener noreferrer">github.com/vitorstanzione/GTFS-Viewer</a></p>
      <p><strong>License:</strong><br />This project is public domain (The Unlicense).<br />You can copy or modify it freely in your own copy.</p>
      <p><strong>Credits:</strong><br />Created with ❤️ by <a href="https://www.linkedin.com/in/vitorstanzione/" target="_blank" rel="noopener noreferrer">Vítor Stanzione</a>, using <strong>OpenAI Codex</strong>.<br />First version on <strong>October 30, 2025</strong>.</p>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    // ===== Elements & state =====
    const tabsEl = document.getElementById('tabs');
    const simpleEl = document.getElementById('tab-simple');
    const validationCard = document.getElementById('validationCard');
    const validationTableBody = document.getElementById('validationTableBody');
    const importStatusEl = document.getElementById('importStatus');

    const FILE_DEFS = [
      { file:'agency.txt', key:'agency', label:'Agency' },
      { file:'areas.txt', key:'areas', label:'Areas' },
      { file:'attributions.txt', key:'attributions', label:'Attributions' },
      { file:'booking_rules.txt', key:'booking_rules', label:'Booking Rules' },
      { file:'calendar.txt', key:'calendar', label:'Calendar' },
      { file:'calendar_dates.txt', key:'calendar_dates', label:'Calendar Dates' },
      { file:'fare_attributes.txt', key:'fare_attributes', label:'Fare Attributes' },
      { file:'fare_leg_join_rules.txt', key:'fare_leg_join_rules', label:'Fare Leg Join Rules' },
      { file:'fare_leg_rules.txt', key:'fare_leg_rules', label:'Fare Leg Rules' },
      { file:'fare_media.txt', key:'fare_media', label:'Fare Media' },
      { file:'fare_products.txt', key:'fare_products', label:'Fare Products' },
      { file:'fare_rules.txt', key:'fare_rules', label:'Fare Rules' },
      { file:'fare_transfer_rules.txt', key:'fare_transfer_rules', label:'Fare Transfer Rules' },
      { file:'feed_info.txt', key:'feed_info', label:'Feed Info' },
      { file:'frequencies.txt', key:'frequencies', label:'Frequencies' },
      { file:'levels.txt', key:'levels', label:'Levels' },
      { file:'location_group_stops.txt', key:'location_group_stops', label:'Location Group Stops' },
      { file:'location_groups.txt', key:'location_groups', label:'Location Groups' },
      { file:'locations.geojson.txt', key:'locations.geojson', label:'Locations.Geojson' },
      { file:'networks.txt', key:'networks', label:'Networks' },
      { file:'pathways.txt', key:'pathways', label:'Pathways' },
      { file:'rider_categories.txt', key:'rider_categories', label:'Rider Categories' },
      { file:'route_networks.txt', key:'route_networks', label:'Route Networks' },
      { file:'routes.txt', key:'routes', label:'Routes' },
      { file:'shapes.txt', key:'shapes', label:'Shapes' },
      { file:'stop_areas.txt', key:'stop_areas', label:'Stop Areas' },
      { file:'stop_times.txt', key:'stop_times', label:'Stop Times' },
      { file:'stops.txt', key:'stops', label:'Stops' },
      { file:'timeframes.txt', key:'timeframes', label:'Timeframes' },
      { file:'transfers.txt', key:'transfers', label:'Transfers' },
      { file:'translations.txt', key:'translations', label:'Translations' },
      { file:'trips.txt', key:'trips', label:'Trips' }
    ];

    const containers = FILE_DEFS.reduce((acc, def) => {
      const el = document.getElementById(`tab-${def.key}`);
      if (el) acc[def.key] = el;
      return acc;
    }, {});

    const FRIENDLY = { home:'Home', simple:'OD time table' };
    FILE_DEFS.forEach(def => { FRIENDLY[def.key] = def.label; });

    const FILES_BY_NAME = FILE_DEFS.reduce((acc, def) => {
      const canonical = def.file.toLowerCase();
      acc[canonical] = def;
      if (canonical.endsWith('.txt')) {
        const csvName = canonical.replace(/\.txt$/, '.csv');
        acc[csvName] = def;
      }
      if (/\.geojson(?:\.txt)?$/.test(canonical)) {
        const geojsonName = canonical.replace(/\.txt$/, '');
        acc[geojsonName] = def;
      }
      return acc;
    }, {});

    const SIMPLE_REQUIRED = ['trips','stop_times','routes'];

    const fileInput = document.getElementById('fileInput');
    const chooseBtn = document.getElementById('chooseBtn');
    const importBtn = document.getElementById('importBtn');
    const clearBtn = document.getElementById('clearBtn');
    const selectedFilesEl = document.getElementById('selectedFiles');
    const failedFilesEl = document.getElementById('failedFiles');
    const failedFilesList = document.getElementById('failedFilesList');
    const originalImportBtnText = importBtn?.textContent || 'Import';

    const loadedFileNames = new Set();
    let stagedFiles = [];
    let parsedData = {};
    let failedImports = [];
    let lastLoadedKey = null;
    let importInProgress = false;
    let importStatusHideTimer = null;
    let parserWorker = null;

    initParserWorker();

    // ===== Tabs =====
    function createTabButton(def, activeId) {
      const button = document.createElement('button');
      button.className = 'tab-btn' + (def.target === activeId ? ' active' : '');
      button.textContent = def.label;
      button.addEventListener('click', () => showContent(def.target));
      return button;
    }

    function setTabs(activeId) {
      tabsEl.innerHTML = '';

      const baseDefs = [{ id:'home', label:FRIENDLY.home, target:'home' }];
      if (simpleEl.dataset.loaded === 'true') {
        baseDefs.push({ id:'simple', label:FRIENDLY.simple, target:'tab-simple' });
      }

      const importedDefs = FILE_DEFS
        .filter(def => containers[def.key]?.dataset.loaded === 'true')
        .map(def => ({ id:def.key, label:def.label, target:`tab-${def.key}` }));

      const headerRow = document.createElement('div');
      headerRow.className = 'tab-header';

      const primaryRow = document.createElement('div');
      primaryRow.className = 'tab-header-left';
      const title = document.createElement('h1');
      title.textContent = 'GTFS Viewer';
      primaryRow.appendChild(title);
      baseDefs.forEach(def => primaryRow.appendChild(createTabButton(def, activeId)));

      const aboutWrap = document.createElement('div');
      aboutWrap.className = 'tab-about';
      const aboutButton = document.createElement('button');
      aboutButton.type = 'button';
      aboutButton.className = 'tab-btn';
      aboutButton.textContent = 'About';
      aboutButton.addEventListener('click', openAboutModal);
      aboutWrap.appendChild(aboutButton);

      headerRow.append(primaryRow, aboutWrap);
      tabsEl.appendChild(headerRow);

      if (importedDefs.length) {
        const group = document.createElement('div');
        group.className = 'tab-group';
        const label = document.createElement('div');
        label.className = 'tab-group-label';
        const row = document.createElement('div');
        row.className = 'tab-row';
        importedDefs.forEach(def => row.appendChild(createTabButton(def, activeId)));
        group.append(label, row);
        tabsEl.appendChild(group);
      }
    }

    function showContent(id) {
      document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
      const el = document.getElementById(id);
      if (el) el.classList.add('active');
      setTabs(id);
    }

    const aboutModal = document.getElementById('aboutModal');
    const aboutClose = aboutModal?.querySelector('.modal-close');

    function openAboutModal(){ if (aboutModal){ aboutModal.hidden = false; aboutModal.focus(); } }
    function closeAboutModal(){ if (aboutModal){ aboutModal.hidden = true; } }

    aboutClose?.addEventListener('click', closeAboutModal);
    aboutModal?.addEventListener('click', event => {
      if (event.target === aboutModal) closeAboutModal();
    });
    document.addEventListener('keydown', event => {
      if (event.key === 'Escape' && !aboutModal?.hidden){
        closeAboutModal();
      }
    });

    // ===== File handling =====
    function handleDrop(ev) {
      if (importInProgress) return;
      ev.preventDefault();
      stagedFiles = Array.from(ev.dataTransfer.files || []);
      renderSelectedFiles();
    }
    if (chooseBtn) chooseBtn.addEventListener('click', () => {
      if (importInProgress) return;
      fileInput.click();
    });
    fileInput.addEventListener('change', () => {
      if (importInProgress) return;
      stagedFiles = Array.from(fileInput.files || []);
      renderSelectedFiles();
    });
    importBtn.addEventListener('click', async () => {
      if (importInProgress) {
        alert('An import is already in progress.');
        return;
      }
      if (!stagedFiles.length) {
        alert('Please select GTFS files to import.');
        return;
      }
      await importSelectedFiles(stagedFiles);
    });
    clearBtn.addEventListener('click', () => {
      if (importInProgress) return;
      stagedFiles=[]; fileInput.value=''; selectedFilesEl.innerHTML='';
      Object.values(containers).forEach(el=>{ el.innerHTML=''; delete el.dataset.loaded; });
      if (simpleEl){ simpleEl.innerHTML=''; delete simpleEl.dataset.loaded; }
      parsedData={}; failedImports=[]; lastLoadedKey=null; loadedFileNames.clear();
      renderFailedFiles(failedImports);
      updateValidationReport();
      updateImportStatus('');
      showContent('home');
    });

    function renderSelectedFiles(){ if (!stagedFiles.length){ selectedFilesEl.innerHTML=''; return;} selectedFilesEl.innerHTML = stagedFiles.map(f=>`<span class="pill file-pill">${f.name}<span style="opacity:.6">${formatSize(f.size)}</span></span>`).join(' '); }
    function formatSize(bytes){ if(bytes<1024)return `${bytes} B`; const kb=bytes/1024; if(kb<1024)return `${kb.toFixed(1)} KB`; const mb=kb/1024; return `${mb.toFixed(2)} MB`; }

    function registerLoadedFile(def, actualName){
      if (!def) return;
      const names = new Set();
      const canonical = String(def.file||'').toLowerCase();
      if (canonical) names.add(canonical);
      if (actualName) names.add(String(actualName).toLowerCase());
      if (canonical.endsWith('.txt')) {
        names.add(canonical.replace(/\.txt$/, '.csv'));
      }
      if (/\.geojson(?:\.txt)?$/.test(canonical)) {
        names.add(canonical.replace(/\.txt$/, ''));
      }
      names.forEach(name => { if (name) loadedFileNames.add(name); });
    }

    function renderFailedFiles(files){
      if (!failedFilesEl || !failedFilesList) return;
      failedFilesList.innerHTML='';
      if (!files.length){ failedFilesEl.hidden=true; return; }
      failedFilesEl.hidden=false;
      const frag=document.createDocumentFragment();
      files.forEach(item=>{
        const li=document.createElement('li');
        const nameSpan=document.createElement('span');
        nameSpan.textContent=item.name;
        li.appendChild(nameSpan);
        if (item.reason){
          const reasonSpan=document.createElement('span');
          reasonSpan.textContent=` — ${item.reason}`;
          reasonSpan.style.opacity='0.75';
          li.appendChild(reasonSpan);
        }
        frag.appendChild(li);
      });
      failedFilesList.appendChild(frag);
    }

    function hasFileReference(names){
      if (!names) return false;
      if (!Array.isArray(names)){
        return loadedFileNames.has(String(names).toLowerCase());
      }
      return names.some(name => loadedFileNames.has(String(name).toLowerCase()));
    }

    function evaluateValidationRules(){
      const results = [];
      const hasCalendar = hasFileReference('calendar.txt');
      const hasCalendarDates = hasFileReference('calendar_dates.txt');
      const hasTranslations = hasFileReference('translations.txt');
      const hasLocations = hasFileReference(['locations.geojson','locations.geojson.txt']);
      const locationsData = parsedData['locations.geojson'];
      let locationsHasData = false;
      if (hasLocations){
        if (!locationsData || !Array.isArray(locationsData.rows)) {
          locationsHasData = true;
        } else {
          locationsHasData = locationsData.rows.length>0;
        }
      }
      const pathwaysData = parsedData.pathways;
      const pathwaysMode5 = (() => {
        if (!pathwaysData) return false;
        const idx = pathwaysData.headers.indexOf('pathway_mode');
        if (idx === -1) return false;
        return pathwaysData.rows.some(row => String(row[idx]||'').trim() === '5');
      })();
      const routesData = parsedData.routes;
      const networkIdExists = (() => {
        if (!routesData) return false;
        const idx = routesData.headers.indexOf('network_id');
        if (idx === -1) return false;
        return routesData.rows.some(row => String(row[idx]||'').trim() !== '');
      })();

      function addConditionalRequired(file, rule, shouldBePresent, lookup){
        const present = hasFileReference(lookup ?? file);
        if (shouldBePresent){
          results.push({ file, rule, status: present ? 'pass' : 'missing-required' });
        } else {
          results.push({ file, rule, status: present ? 'pass' : 'missing-ok' });
        }
      }
      function addRequired(file, rule, lookup){ addConditionalRequired(file, rule, true, lookup); }
      function addOptional(file, rule, lookup){ addConditionalRequired(file, rule, false, lookup); }
      function addForbidden(file, rule, isForbidden, lookup){
        const present = hasFileReference(lookup ?? file);
        if (isForbidden){
          results.push({ file, rule, status: present ? 'forbidden' : 'pass' });
        } else {
          results.push({ file, rule, status: present ? 'pass' : 'missing-ok' });
        }
      }

      addRequired('agency.txt','Required');
      addOptional('areas.txt','Optional');
      addOptional('attributions.txt','Optional');
      addOptional('booking_rules.txt','Optional');
      addConditionalRequired('calendar.txt','Required if calendar_dates.txt is missing', !hasCalendarDates);
      addConditionalRequired('calendar_dates.txt','Required if calendar.txt is missing', !hasCalendar);
      addOptional('fare_attributes.txt','Optional');
      addOptional('fare_leg_join_rules.txt','Optional');
      addOptional('fare_leg_rules.txt','Optional');
      addOptional('fare_media.txt','Optional');
      addOptional('fare_products.txt','Optional');
      addOptional('fare_rules.txt','Optional');
      addOptional('fare_transfer_rules.txt','Optional');
      addConditionalRequired('feed_info.txt','Required if translations.txt is provided', hasTranslations);
      addOptional('frequencies.txt','Optional');
      addConditionalRequired('levels.txt','Required if pathways.pathway_mode=5', pathwaysMode5);
      addOptional('location_group_stops.txt','Optional');
      addOptional('location_groups.txt','Optional');
      addOptional('locations.geojson','Optional',['locations.geojson','locations.geojson.txt']);
      addForbidden('networks.txt','Forbidden if network_id exists in routes.txt', networkIdExists);
      addOptional('pathways.txt','Optional');
      addOptional('rider_categories.txt','Optional');
      addForbidden('route_networks.txt','Forbidden if network_id exists in routes.txt', networkIdExists);
      addRequired('routes.txt','Required');
      addOptional('shapes.txt','Optional');
      addOptional('stop_areas.txt','Optional');
      addRequired('stop_times.txt','Required');
      addConditionalRequired('stops.txt','Required if locations.geojson has no data', !hasLocations || !locationsHasData);
      addOptional('timeframes.txt','Optional');
      addOptional('transfers.txt','Optional');
      addOptional('translations.txt','Optional');
      addRequired('trips.txt','Required');

      return results;
    }

    function updateValidationReport(){
      if (!validationCard || !validationTableBody) return;
      if (!loadedFileNames.size){
        validationTableBody.innerHTML='';
        validationCard.hidden=true;
        return;
      }
      const results = evaluateValidationRules();
      const statusMeta = {
        pass: { text:'FOUND', className:'status-badge status-pass' },
        'missing-ok': { text:'MISSING', className:'status-badge status-missing-ok' },
        'missing-required': { text:'MISSING', className:'status-badge status-missing-required' },
        forbidden: { text:'FOUND', className:'status-badge status-forbidden' }
      };
      validationTableBody.innerHTML='';
      const frag = document.createDocumentFragment();
      results.forEach(item => {
        const tr = document.createElement('tr');
        const tdFile = document.createElement('td');
        tdFile.textContent = item.file;
        const tdRule = document.createElement('td');
        tdRule.textContent = item.rule;
        const tdStatus = document.createElement('td');
        const meta = statusMeta[item.status] || statusMeta['missing-ok'];
        const badge = document.createElement('span');
        badge.className = meta.className;
        badge.textContent = meta.text;
        tdStatus.appendChild(badge);
        tr.append(tdFile, tdRule, tdStatus);
        frag.appendChild(tr);
      });
      validationTableBody.appendChild(frag);
      validationCard.hidden=false;
    }

    async function importSelectedFiles(files){
      if (importInProgress) return;
      const payload = Array.isArray(files) ? files.slice() : Array.from(files || []);
      setImportInProgress(true);
      updateImportStatus('Preparing import...');
      try {
        if (!parserWorker) {
          initParserWorker();
        }
        parserWorker.postMessage({ type:'import', files: payload });
      } catch (err) {
        console.error('Failed to start import', err);
        handleWorkerError('Unable to start import');
      }
    }

    function setImportInProgress(flag){
      importInProgress = flag;
      if (importBtn){
        importBtn.disabled = flag;
        importBtn.textContent = flag ? 'Importing…' : originalImportBtnText;
      }
      if (chooseBtn) chooseBtn.disabled = flag;
      if (clearBtn) clearBtn.disabled = flag;
    }

    function handleWorkerMessage(event){
      const data = event.data || {};
      if (data.type === 'progress'){
        const processed = Number.isFinite(data.processed) ? data.processed : 0;
        const total = Number.isFinite(data.total) ? data.total : 0;
        const message = data.message ? String(data.message) : '';
        const current = data.current ? String(data.current) : '';
        const parts = [];
        if (message) parts.push(message);
        if (total > 0){
          parts.push(`${Math.min(processed, total)}/${total}`);
        } else if (processed > 0){
          parts.push(String(processed));
        }
        if (current) parts.push(current);
        updateImportStatus(parts.join(' • '));
      } else if (data.type === 'complete'){
        handleImportComplete(data);
      } else if (data.type === 'error'){
        console.error('Worker reported error', data.message);
        handleWorkerError(data.message || 'Worker error');
      }
    }

    function handleImportComplete(data){
      const results = Array.isArray(data.results) ? data.results : [];
      const failed = Array.isArray(data.failed) ? data.failed : [];
      const aggregatedFailed = [...failed];
      let lastImportedKey = null;

      for (const entry of results){
        if (!entry) continue;
        const lowerName = entry.lowerName || String(entry.name || '').toLowerCase();
        const def = lowerName ? FILES_BY_NAME[lowerName] : null;
        if (def && containers[def.key]) {
          if (entry.parsed && Array.isArray(entry.parsed.headers) && Array.isArray(entry.parsed.rows)){
            parsedData[def.key] = entry.parsed;
            renderDataTable(containers[def.key], entry.parsed.headers, entry.parsed.rows, def.label);
            containers[def.key].dataset.loaded='true';
            registerLoadedFile(def, entry.name || lowerName);
            lastImportedKey = def.key;
          } else {
            const reason = entry.sourceZip ? `No data parsed (from ${entry.sourceZip})` : 'No data parsed';
            aggregatedFailed.push({ name: entry.name || def.file, reason });
          }
        } else {
          const reason = entry.sourceZip ? `Unsupported file (from ${entry.sourceZip})` : 'Unsupported file';
          aggregatedFailed.push({ name: entry.name || 'Unknown file', reason });
        }
      }

      if (lastImportedKey){
        lastLoadedKey = lastImportedKey;
      }

      failedImports = aggregatedFailed;
      renderFailedFiles(failedImports);
      updateValidationReport();

      const previouslyActiveId = document.querySelector('.content.active')?.id || 'home';
      const simpleReady = SIMPLE_REQUIRED.every(key => containers[key]?.dataset.loaded==='true');
      if (simpleReady) {
        buildAndRenderSimpleTable();
      }

      let targetId = previouslyActiveId === 'tab-simple' && !simpleReady
        ? 'home'
        : previouslyActiveId;
      if (targetId !== 'home') {
        const targetEl = document.getElementById(targetId);
        const isSimpleTab = targetId === 'tab-simple';
        const isLoaded = isSimpleTab
          ? simpleEl?.dataset?.loaded === 'true'
          : targetEl?.dataset?.loaded === 'true';
        if (!isLoaded) {
          targetId = 'home';
        }
      }
      showContent(targetId);

      setImportInProgress(false);
      updateImportStatus('Import complete', { autoHide: 2000 });
    }

    function handleWorkerError(detail){
      console.error('Import worker error:', detail);
      setImportInProgress(false);
      updateImportStatus('Import failed', { autoHide: 4000 });
      initParserWorker();
      alert('Import failed. Please check the console for more details.');
    }

    function updateImportStatus(text, options = {}){
      if (!importStatusEl) return;
      clearTimeout(importStatusHideTimer);
      if (!text){
        importStatusEl.hidden = true;
        importStatusEl.textContent = '';
        return;
      }
      importStatusEl.hidden = false;
      importStatusEl.textContent = text;
      if (options.autoHide){
        importStatusHideTimer = setTimeout(() => {
          importStatusEl.hidden = true;
          importStatusEl.textContent = '';
        }, options.autoHide);
      }
    }

    function initParserWorker(){
      if (parserWorker){
        parserWorker.terminate();
      }
      parserWorker = createParserWorker();
      parserWorker.addEventListener('message', handleWorkerMessage);
      parserWorker.addEventListener('error', event => {
        console.error('Parser worker error', event);
        handleWorkerError('Worker error encountered');
      });
    }

    function createParserWorker(){
      const workerSource = String.raw`
self.importScripts('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');

function createIncrementalCSVParser(){
  const rows=[];
  let row=[];
  let cur='';
  let inQ=false;
  let awaitingSecondQuote=false;
  let skipNextLF=false;
  return {
    processChunk(chunk){
      if (!chunk) return;
      let i=0;
      while (i<chunk.length){
        let ch=chunk[i];
        if (skipNextLF){
          skipNextLF=false;
          if (ch=='\n'){ i++; continue; }
        }
        if (awaitingSecondQuote){
          if (ch=='"'){
            cur+='"';
            awaitingSecondQuote=false;
            i++;
            continue;
          }
          awaitingSecondQuote=false;
          inQ=false;
        }
        if (ch=='\r'){
          skipNextLF=true;
          ch='\n';
        }
        if (ch=='"'){
          if (inQ){
            if (i+1<chunk.length){
              if (chunk[i+1]=='"'){
                cur+='"';
                i+=2;
                continue;
              }
              inQ=false;
              i++;
              continue;
            }
            awaitingSecondQuote=true;
            i++;
            continue;
          }
          inQ=true;
          i++;
          continue;
        }
        if (ch==',' && !inQ){
          row.push(cur);
          cur='';
          i++;
          continue;
        }
        if (ch=='\n' && !inQ){
          row.push(cur);
          cur='';
          if (row.length && !(row.length===1 && row[0]==='')) rows.push(row);
          row=[];
          i++;
          continue;
        }
        cur+=ch;
        i++;
      }
    },
    finish(){
      if (awaitingSecondQuote){
        awaitingSecondQuote=false;
        inQ=false;
      }
      if (cur.length || row.length){
        row.push(cur);
        rows.push(row);
      }
      if (!rows.length) return { headers:[], rows:[] };
      const headers = rows.shift();
      const norm = rows.map(r => r.length<headers.length ? r.concat(Array(headers.length-r.length).fill('')) : r);
      return { headers, rows:norm };
    }
  };
}

function parseCSVText(text){
  const parser = createIncrementalCSVParser();
  parser.processChunk(text);
  return parser.finish();
}

async function parseBlobToTable(blob){
  if (blob && blob.stream && typeof TextDecoderStream === 'function'){
    try {
      const parser = createIncrementalCSVParser();
      const reader = blob.stream().pipeThrough(new TextDecoderStream()).getReader();
      try {
        while (true){
          const result = await reader.read();
          if (result.done) break;
          if (result.value) parser.processChunk(result.value);
        }
      } finally {
        reader.releaseLock();
      }
      return parser.finish();
    } catch (err){
      // Fallback handled below
    }
  }
  const text = await blob.text();
  return parseCSVText(text);
}

function buildProgressPayload(processed, total, current, message){
  return { type:'progress', processed, total, current, message };
}

async function handleImport(files){
  const results = [];
  const failed = [];
  const tasks = [];
  let total = 0;

  for (const file of files){
    const name = file && file.name ? String(file.name) : 'file';
    const lowerName = name.toLowerCase();
    if (lowerName.endsWith('.zip')){
      try {
        const buffer = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(buffer);
        const entries = [];
        let order = 0;
        zip.forEach(function(relativePath, entry){
          if (entry.dir) return;
          const baseName = relativePath.split('/').pop();
          if (!baseName) return;
          const lower = baseName.toLowerCase();
          if (!lower.endsWith('.txt') && !lower.endsWith('.csv')) return;
          entries.push({ order: order++, entry: entry, name: baseName, lowerName: lower });
        });
        entries.sort(function(a,b){ return a.order - b.order; });
        total += entries.length;
        tasks.push({ type:'zip', entries: entries, zipName: name });
      } catch (err){
        failed.push({ name: name, reason: 'Unable to read ZIP archive' });
      }
    } else {
      total += 1;
      tasks.push({ type:'file', file: file, name: name, lowerName: lowerName });
    }
  }

  let processed = 0;
  self.postMessage(buildProgressPayload(processed, total, null, total ? 'Starting import' : 'No supported files'));

  for (const task of tasks){
    if (task.type === 'file'){
      try {
        const parsed = await parseBlobToTable(task.file);
        results.push({ name: task.name, lowerName: task.lowerName, parsed: parsed });
      } catch (err){
        failed.push({ name: task.name, reason: 'Unable to read file' });
      }
      processed += 1;
      self.postMessage(buildProgressPayload(processed, total, task.name, 'Processed file'));
    } else if (task.type === 'zip'){
      for (const entryInfo of task.entries){
        try {
          const text = await entryInfo.entry.async('string');
          const parsed = parseCSVText(text);
          results.push({ name: entryInfo.name, lowerName: entryInfo.lowerName, parsed: parsed, sourceZip: task.zipName });
        } catch (err){
          const failReason = task.zipName ? 'Unable to read file from ' + task.zipName : 'Unable to read file from ZIP';
          failed.push({ name: entryInfo.name, reason: failReason });
        }
        processed += 1;
        const label = task.zipName ? 'Processed ZIP entry' : 'Processed file';
        const info = task.zipName ? label + ' (' + task.zipName + ')' : label;
        self.postMessage(buildProgressPayload(processed, total, entryInfo.name, info));
      }
    }
  }

  self.postMessage({ type:'complete', results: results, failed: failed });
}

self.onmessage = function(event){
  const data = event.data || {};
  if (data.type === 'import'){
    handleImport(Array.isArray(data.files) ? data.files : []).catch(function(err){
      self.postMessage({ type:'error', message: err && err.message ? err.message : 'Unknown worker error' });
    });
  }
};
`;
      const blob = new Blob([workerSource], { type:'application/javascript' });
      const url = URL.createObjectURL(blob);
      const worker = new Worker(url);
      URL.revokeObjectURL(url);
      return worker;
    }

    // ===== Generic table with filters + pagination + rendering =====
    function createState(headers, rows){ return { headers, rows, filters: headers.map(()=>''), page:1, pageSize:50, sortColumn:null, sortDirection:'asc' }; }
    function applyFilters(rows, headers, filters){ const f=filters.map(v=>{v=(v||'').trim(); return !v?{m:'none'}:v.startsWith('=')?{m:'eq',v:v.slice(1).toLowerCase()}:{m:'in',v:v.toLowerCase()};}); return rows.filter(r=>r.every((c,i)=>{const fl=f[i]; if(fl.m==='none')return true; const s=String(c||'').toLowerCase(); return fl.m==='eq'? s===fl.v : s.includes(fl.v);})); }
    function paginate(rows,page,pageSize){ const total=rows.length; const pages=Math.max(1,Math.ceil(total/pageSize)); const p=Math.min(Math.max(1,page),pages); const start=(p-1)*pageSize; return { pageRows: rows.slice(start,start+pageSize), page:p, pages, total }; }
    function mkBtn(t){ const b=document.createElement('button'); b.className='btn'; b.type='button'; b.textContent=t; return b; }
    function isValidHex6(v){ return /^[#]?[0-9a-fA-F]{6}$/.test(String(v||'')); }
    function normalizeHex(v){ v=String(v||'').trim(); return v? (v.startsWith('#')? v : '#'+v) : ''; }

    function sanitizeFileName(name){
      const base=String(name||'data').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
      return base || 'data';
    }
    function rowsToCSV(headers, rows){
      const allRows=[headers, ...rows];
      return allRows.map(row=>row.map(cell=>{
        const value=String(cell??'');
        return /[",\n]/.test(value) ? '"'+value.replace(/"/g,'""')+'"' : value;
      }).join(',')).join('\n');
    }
    function rowsToJSON(headers, rows){
      const objects=rows.map(row=>{
        const obj={};
        headers.forEach((h,idx)=>{ obj[h]=row[idx]??''; });
        return obj;
      });
      return JSON.stringify(objects,null,2);
    }
    function downloadTextFile(filename, text, mime){
      const blob=new Blob([text],{ type:(mime||'text/plain')+';charset=utf-8' });
      const url=URL.createObjectURL(blob);
      const link=document.createElement('a');
      link.href=url;
      link.download=filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      setTimeout(()=>URL.revokeObjectURL(url),0);
    }
    function copyToClipboard(text){
      if (navigator.clipboard?.writeText){
        return navigator.clipboard.writeText(text);
      }
      return new Promise((resolve,reject)=>{
        const textarea=document.createElement('textarea');
        textarea.value=text;
        textarea.style.position='fixed';
        textarea.style.top='-9999px';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        try {
          document.execCommand('copy');
          resolve();
        } catch (err) {
          reject(err);
        } finally {
          document.body.removeChild(textarea);
        }
      });
    }

    function renderDataTable(container, headers, rows, title){
      container.innerHTML=''; const state=createState(headers,rows); container.__state=state;
      const card=document.createElement('div'); card.className='card';
      const headerBar=document.createElement('div'); headerBar.className='toolbar';
      const titleEl=document.createElement('h2'); titleEl.style.margin='0'; titleEl.textContent=title;
      const countEl=document.createElement('span'); countEl.className='pill'; countEl.textContent=`${rows.length.toLocaleString()} rows`;
      const exportWrap=document.createElement('div'); exportWrap.className='actions';
      const exportSelect=document.createElement('select'); exportSelect.className='select'; exportSelect.setAttribute('aria-label','Export data');
      const placeholderOption=document.createElement('option'); placeholderOption.value=''; placeholderOption.textContent='Export'; placeholderOption.selected=true; placeholderOption.disabled=true; placeholderOption.hidden=true; exportSelect.appendChild(placeholderOption);
      [
        { value:'csv', label:'CSV' },
        { value:'json', label:'JSON' },
        { value:'clipboard', label:'Clipboard' }
      ].forEach(opt=>{ const o=document.createElement('option'); o.value=opt.value; o.textContent=opt.label; exportSelect.appendChild(o); });
      const exportMessage=document.createElement('span'); exportMessage.className='pill'; exportMessage.hidden=true;
      exportWrap.append(exportSelect,exportMessage);
      const spacer=document.createElement('div'); spacer.className='spacer';
      const pageSizeSel=document.createElement('select'); pageSizeSel.className='select'; [25,50,100,250,1000].forEach(n=>{const o=document.createElement('option'); o.value=String(n); o.textContent=`${n}/page`; pageSizeSel.appendChild(o);}); pageSizeSel.value=String(state.pageSize);
      const pager=document.createElement('div'); pager.className='pagination';
      const btnFirst=mkBtn('⏮'), btnPrev=mkBtn('◀'), pageInfo=document.createElement('span'), btnNext=mkBtn('▶'), btnLast=mkBtn('⏭'); pageInfo.className='pill';
      pager.append(btnFirst,btnPrev,pageInfo,btnNext,btnLast);
      headerBar.append(titleEl,countEl,exportWrap,spacer,pageSizeSel,pager);
      const scroller=document.createElement('div'); scroller.className='scroll';
      const table=document.createElement('table');
      const thead=document.createElement('thead'); const trHead=document.createElement('tr'); const headerCells=[]; headers.forEach((h,idx)=>{ const th=document.createElement('th'); th.classList.add('sortable'); th.setAttribute('aria-sort','none'); const inner=document.createElement('span'); inner.className='header-inner'; const label=document.createElement('span'); label.textContent=h; const indicator=document.createElement('span'); indicator.className='sort-indicator'; indicator.textContent=''; inner.append(label,indicator); th.appendChild(inner); th.addEventListener('click',()=>{ if(state.sortColumn===idx){ state.sortDirection=state.sortDirection==='asc'?'desc':'asc'; } else { state.sortColumn=idx; state.sortDirection='asc'; } state.page=1; draw(); }); headerCells.push({th,indicator}); trHead.appendChild(th); }); thead.appendChild(trHead);
      const trFilters=document.createElement('tr'); trFilters.className='filters'; headers.forEach((h,idx)=>{ const th=document.createElement('th'); const input=document.createElement('input'); input.className='filter-input'; input.type='text'; input.placeholder='Filter'; input.value=state.filters[idx]; input.addEventListener('input',()=>{ state.filters[idx]=input.value; state.page=1; draw(); }); th.appendChild(input); trFilters.appendChild(th); }); thead.appendChild(trFilters);
      const tbody=document.createElement('tbody'); table.appendChild(thead); table.appendChild(tbody); scroller.appendChild(table); card.appendChild(headerBar); card.appendChild(scroller); container.appendChild(card);

      function computeActiveRows(){
        const filteredRows=applyFilters(state.rows,state.headers,state.filters);
        let workingRows=filteredRows;
        if (Number.isInteger(state.sortColumn)){
          const idx=state.sortColumn;
          const dir=state.sortDirection==='desc'?-1:1;
          workingRows=[...filteredRows].sort((a,b)=>{
            const av=a[idx]??'';
            const bv=b[idx]??'';
            return dir*String(av).localeCompare(String(bv),undefined,{numeric:true,sensitivity:'base'});
          });
        }
        state.filteredRows=filteredRows;
        state.workingRows=workingRows;
        return { filteredRows, workingRows };
      }

      function draw(){
        const { filteredRows, workingRows } = computeActiveRows();
        const {pageRows,page,pages}=paginate(workingRows,state.page,state.pageSize); state.page=page;
        tbody.innerHTML=''; const frag=document.createDocumentFragment();
        pageRows.forEach(r=>{ const tr=document.createElement('tr'); r.forEach((cell,idx)=>{ const td=document.createElement('td'); const header=state.headers[idx]||''; const val=String(cell||'');
          if (/url/i.test(header) && /^https?:\/\//i.test(val)) { const a=document.createElement('a'); a.href=val; a.textContent=val; a.target='_blank'; a.rel='noopener noreferrer'; td.appendChild(a); }
          else if (/color/i.test(header) && isValidHex6(val)) { const chip=document.createElement('span'); chip.className='chip'; const sw=document.createElement('span'); sw.className='chip-swatch'; sw.style.background=normalizeHex(val); const tx=document.createElement('span'); tx.textContent=val.replace(/^#/,'').toUpperCase(); if (/route_text_color/i.test(header)) tx.style.color=normalizeHex(val); chip.appendChild(sw); chip.appendChild(tx); td.appendChild(chip); }
          else { td.textContent=val; if (/(?:_id$)|^(?:\d{1,2}:\d{2}:\d{2})$/.test(header)) td.style.fontFamily='ui-monospace,SFMono-Regular,Menlo,Consolas,monospace'; }
          tr.appendChild(td); }); frag.appendChild(tr); });
        tbody.appendChild(frag); pageInfo.textContent=`Page ${page} / ${pages}`; countEl.textContent=`${filteredRows.length.toLocaleString()} rows`;
        headerCells.forEach(({th,indicator},idx)=>{
          const isActive=state.sortColumn===idx;
          th.classList.toggle('sort-active',isActive);
          th.setAttribute('aria-sort',isActive ? (state.sortDirection==='asc'?'ascending':'descending') : 'none');
          if (!isActive){ indicator.textContent=''; return; }
          indicator.textContent=state.sortDirection==='asc'?'▲':'▼';
        });
        btnFirst.disabled=page<=1; btnPrev.disabled=page<=1; btnNext.disabled=page>=pages; btnLast.disabled=page>=pages;
      }
      pageSizeSel.addEventListener('change',()=>{ state.pageSize=parseInt(pageSizeSel.value,10); state.page=1; draw(); });
      btnFirst.addEventListener('click',()=>{ state.page=1; draw(); }); btnPrev.addEventListener('click',()=>{ state.page=Math.max(1,state.page-1); draw(); }); btnNext.addEventListener('click',()=>{ state.page=state.page+1; draw(); }); btnLast.addEventListener('click',()=>{ const { filteredRows } = computeActiveRows(); state.page=Math.max(1,Math.ceil(filteredRows.length/state.pageSize)); draw(); });
      function prepareExportRows(){
        const { workingRows } = computeActiveRows();
        return workingRows;
      }
      function showExportMessage(text, timeout=2000){
        exportMessage.textContent=text;
        exportMessage.hidden=false;
        if (timeout){
          clearTimeout(exportMessage._hideTimer);
          exportMessage._hideTimer=setTimeout(()=>{ exportMessage.hidden=true; },timeout);
        }
      }
      exportSelect.addEventListener('change',()=>{
        const { value } = exportSelect;
        if (!value) return;
        const activeRows=prepareExportRows();
        if (value==='csv'){
          const csv=rowsToCSV(state.headers,activeRows);
          const fileName=`${sanitizeFileName(title)}.csv`;
          downloadTextFile(fileName,csv,'text/csv');
          showExportMessage('CSV download started');
        } else if (value==='json'){
          const json=rowsToJSON(state.headers,activeRows);
          const fileName=`${sanitizeFileName(title)}.json`;
          downloadTextFile(fileName,json,'application/json');
          showExportMessage('JSON download started');
        } else if (value==='clipboard'){
          const csv=rowsToCSV(state.headers,activeRows);
          copyToClipboard(csv)
            .then(()=>{ showExportMessage('Copied CSV to clipboard'); })
            .catch(()=>{ showExportMessage('Copy failed',3000); });
        }
        exportSelect.selectedIndex=0;
      });
      draw();
    }

    // ===== OD Time Table =====
    function buildAndRenderSimpleTable(){
      const trips = parsedData.trips;
      const stopTimes = parsedData.stop_times;
      const routes = parsedData.routes;
      if (!trips || !stopTimes || !routes) {
        if (simpleEl){ simpleEl.innerHTML=''; delete simpleEl.dataset.loaded; }
        return;
      }
      const tH = trips.headers, tR = trips.rows;
      const sH = stopTimes.headers, sR = stopTimes.rows;
      const rH = routes.headers, rR = routes.rows;

      const IDX = {
        trips: { route_id: tH.indexOf('route_id'), trip_id: tH.indexOf('trip_id') },
        stop_times: { trip_id: sH.indexOf('trip_id'), arrival_time: sH.indexOf('arrival_time'), departure_time: sH.indexOf('departure_time'), stop_id: sH.indexOf('stop_id'), stop_sequence: sH.indexOf('stop_sequence') },
        routes: { route_id: rH.indexOf('route_id'), route_short_name: rH.indexOf('route_short_name') }
      };

      // Build stop summaries per trip (origin/destination)
      const byTrip = new Map();
      for (const row of sR){
        const tripId=row[IDX.stop_times.trip_id]; const seq=Number(row[IDX.stop_times.stop_sequence]||0);
        const arr=row[IDX.stop_times.arrival_time]; const dep=row[IDX.stop_times.departure_time]; const stop=row[IDX.stop_times.stop_id];
        if (!byTrip.has(tripId)) byTrip.set(tripId,{ minSeq:seq, maxSeq:seq, origin:{stop_id:stop, dep_time:dep}, dest:{stop_id:stop, arr_time:arr} });
        const rec=byTrip.get(tripId);
        if (seq<rec.minSeq){ rec.minSeq=seq; rec.origin={stop_id:stop, dep_time:dep}; }
        if (seq>rec.maxSeq){ rec.maxSeq=seq; rec.dest={stop_id:stop, arr_time:arr}; }
      }

      // route_id => route_short_name map
      const routeShort = new Map();
      for (const rr of rR){ routeShort.set(rr[IDX.routes.route_id], rr[IDX.routes.route_short_name]||''); }

      const simpleHeaders=['Trip ID','Route ID','Sign (route_short_name)','Origin Stop ID','Destination Stop ID','Departure Time','Arrival Time'];
      const simpleRows=[];
      for (const row of tR){
        const routeId=row[IDX.trips.route_id]; const tripId=row[IDX.trips.trip_id];
        const sign=routeShort.get(routeId)||''; const times=byTrip.get(tripId)||{origin:{stop_id:'',dep_time:''},dest:{stop_id:'',arr_time:''}};
        simpleRows.push([tripId, routeId, sign, times.origin.stop_id||'', times.dest.stop_id||'', times.origin.dep_time||'', times.dest.arr_time||'']);
      }
      renderDataTable(simpleEl, simpleHeaders, simpleRows, FRIENDLY.simple);
      simpleEl.dataset.loaded='true'; setTabs('tab-simple');
    }

    // ===== Init =====
    setTabs('home');
  </script>
</body>

</html>


